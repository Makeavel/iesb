/Felippe é funcionário de uma vidraçaria e precisa encontrar retalhos de vidro que consigam preencher um vão em uma obra.
Seu programa deverá solicitar ao usuário o tamanho do vão a ser preenchido e o nome do arquivo que contem o tamanho dos retalhos.
Exemplo do arquivo
10
13
15
12
1
5
19
45
Para o tamanho dos retalhos lidos diga se é possível ou não preencher o vão utilizando uma solução recursiva/

#include<stdio.h>
#include<stdlib.h>

int recursiva(int vetor[100], int indice, int vao);

int main(){
    FILE *arq;

    char linha[100];
    char nome_arquivo[100];

    int i = 1;
    int j = 0;
    int tam_vao = 0;

    int numero;
    int vetor[100];

    printf("\nDigite o nome do arquivo: ");
    scanf("%s",&nome_arquivo);

    printf("\nDigite o tamanho do vão a ser preenchido: ");
    scanf("%s",&tam_vao);

    arq = fopen(nome_arquivo, "rt");

    if(arq==NULL){
        printf("\nArquivo não encontrado");
        return 0;
    }

    i = 0;

    while(fscanf(arq,"%d\n",&numero)!=EOF){
        printf("\nNúmero lido: %d",numero);
        vetor[i] = numero;
        i++;
    }

    while(i--){
        printf("\nNúmero: %d",vetor[i]);
    }

    int n = 0;

    printf("\n%d",recursiva(vetor, n+1, tam_vao));

    fclose(arq);

    return 0;
}

int recursiva(int vetor[100], int indice, int vao){
    if(vetor[indice] < vao){
        print("\nNão é possível preencher o vão com este tamanho de retalho");
        return 1
    }else{
        printf("\nÉ possível preencher o vão com este tamanho de retalho");
        return recursiva(vetor[indice+1], indice+1, vao);
    }
}


RECURSIVIDADE:
f(n) = c + f(n-1) -> complexidade: O(n) 
f(n) = c + n * f(n-1) -> complexidade: O(n^2)
f(n) = c + f(n/2) -> complexidade: O(log(n))
f(n) = n + 2 * f(n/2) -> complexidade: O(nlog(n))
f(n) = c + 2 * f(n-1) -> complexidade: O(2^n)

Fibonacci -> exponencial
Percorre arvore binária -> exponencial
for(i=0;i<n;i++){} -> complexidade: O(n)
for(i=0;i<n;i=i/2){} -> complexidade: O(log(n))

Boyer-Moore -> M * N
    - melhor forma para pesquisar textos do dia a dia

KMP
    - melhor para quando tiver várias repetições de caracteres

Rabin Karp
    - melhor para quando atingiram os padrões grandes e quando não há necessidade de exatidão de resposta, podendo haver falso positivo 
